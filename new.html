<!DOCTYPE html>
<meta charset="utf-8">
<style>

/* CSS goes here. */

</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script>

/* JavaScript goes here. */

var width  = 1500;
var height = 1500;

var vis = d3.select( "body" )
  .append( "svg" )
  .attr( "width", width )
  .attr( "height", height );

queue()
  .defer(d3.json, 'freeways.json')
  .defer(d3.json, 'streets.json')
  .defer(d3.json, 'neighborhoods.json')
  .defer(d3.json, 'arteries.json')
  .await(makeMyMap);

var agency = "sf-muni";

function makeMyMap(error, freeways, streets, neighborhoods, arteries) {
    var center = d3.geo.centroid(freeways)
    var scale  = 150;
    var offset = [width/2, height/2];
    var projection = d3.geo.mercator().scale(scale).center(center)
        .translate(offset);

    // create the path
    var path = d3.geo.path().projection(projection);

    // using the path determine the bounds of the current map and use 
    // these to determine better values for the scale and translation
    var bounds  = path.bounds(freeways);
    var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
    var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
    var scale   = (hscale < vscale) ? hscale : vscale;
    var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                      height - (bounds[0][1] + bounds[1][1])/2];

    // new projection
    projection = d3.geo.mercator().center(center)
      .scale(scale).translate(offset);
    path = path.projection(projection);

    // add a rectangle to see the bound of the svg
    vis.append("rect").attr('width', width).attr('height', height)
      .style('stroke', 'black').style('fill', 'none');

    vis.selectAll("path").data(streets.features).enter().append("path")
      .attr("d", path)
      .style("stroke-width", "1")
      .style("stroke", "black")
    vis.selectAll("path").data(freeways.features).enter().append("path")
      .attr("d", path)
      .style("stroke-width", "1")
      .style("stroke", "black");
    vis.selectAll("path").data(neighborhoods.features).enter().append("path")
      .attr("d", path)
      .style("stroke-width", "1")
      .style("stroke", "black");
    vis.selectAll("path").data(arteries.features).enter().append("path")
      .attr("d", path)
      .style("stroke-width", "1")
      .style("stroke", "black")

    var positions = [];
    
    drawData(true);
    (function animate() {
    //   console.log(positions.length);
    //   console.log('updated');
    //   d3.select("svg").selectAll("circle").remove();
    //   console.log(positions.length);
      next();
      // drawData(false);
      setTimeout(animate, 15000);
    }());

    function drawData(first) {
      // d3.select("svg").selectAll("circle").remove();
      $.get( "http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a="+ agency, function( data ) {
        $(data).find("vehicle").each(function() {
          var marker = $(this);
          var point = projection([
            marker.attr("lon"),
            marker.attr("lat")
          ]);
          positions.push(point);
          // vis.append('svg:circle')
          //     .attr('class', 'muni')
          //     .attr('cx', point[0])
          //     .attr('cy', point[1])
          //     .attr('r', 5)
          //     .attr('stroke', 'red')
          //     .attr('fill', 'red');
        });
        vis.selectAll("circle")
          .data(positions)
          .enter()
          .append("circle")  // Add circle svg
          .attr('class', 'muni')
          .attr("cx", function(d) {
              return d[0];  // Circle's X
          })
          .attr("cy", function(d) {  // Circle's Y
              return d[1];
          })
          .attr("r", 10)  // radius
          .attr('fill', 'red');
      });
    }

    function next() {
      var len = positions.length;
      var count = 0;
      positions = [];
      $.get( "http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a="+ agency, function( data ) {
        console.log(data);
        $(data).find("vehicle").each(function() {
          if (count >= len) {
            return false;
          }
          var marker = $(this);
          var point = projection([
            marker.attr("lon"),
            marker.attr("lat")
          ]);
          positions.push(point);
          // vis.append('svg:circle')
          //     .attr('cx', point[0])
          //     .attr('cy', point[1])
          //     .attr('r', 5)
          //     .attr('stroke', 'red')
          //     .attr('fill', 'red');
          count += 1;
        });
        console.log(positions.length);
        // Update circles
        vis.selectAll("circle")
          .data(positions)  // Update with new data
          .transition()  // Transition from old to new
          .duration(1000)  // Length of animation
          .each("start", function() {  // Start animation
              d3.select(this)  // 'this' means the current element
                  .attr("fill", "red")  // Change color
                  .attr("r", 5);  // Change size
          })
          .delay(function() {
              return 500;  // Dynamic delay (i.e. each item delays a little longer)
          })
          //.ease("linear")  // Transition easing - default 'variable' (i.e. has acceleration), also: 'circle', 'elastic', 'bounce', 'linear'
          .attr("cx", function(d) {
              return d[0];  // Circle's X
          })
          .attr("cy", function(d) {
              return d[1];  // Circle's Y
          })
          .each("end", function() {  // End animation
              d3.select(this)  // 'this' means the current element
                  .transition()
                  .duration(500)
                  .attr("fill", "orange")  // Change color
                  .attr("r", 50);  // Change radius
          });
      });
    }
}

function check(first, array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time 
    if (first.length != array.length)
        return false;

    for (var i = 0, l=first.length; i < l; i++) {
        // Check if we have nested arrays
        if (first[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!first[i].equals(array[i]))
                return false;       
        }           
        else if (first[i] != array[i]) { 
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;   
        }           
    }       
    return true;
}



</script>